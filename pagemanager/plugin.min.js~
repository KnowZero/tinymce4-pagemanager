/**
 *
 * Copyright, KnowZero
 * Released under Apache 2.0 License.
 * Version 0.01-Alpha
 *
 * Contributing: https://github.com/KnowZero/tinymce4-pagemanager
 */

tinymce.PluginManager.add('pagemanager', function(editor, url) {


 var pm_sectionOrderHash = {};
 var pm_sectionOrder = (editor.getParam('pm_section_order')||'').split('');
 var pm_sectionDef = editor.getParam('pm_section_def');
 console.log( editor.getParam('pm_section_order') );
 $.each( pm_sectionOrder, function (i,val) {
	pm_sectionOrderHash[val]=i;
 });

 var pm_pages={};

 // Load Stylesheet into UI
 var css_link = $("<link>", {
    rel: "stylesheet",
    type: "text/css",
    href: url + '/css/default.css'
 });
 css_link.appendTo('head');
 
 
 

 
 
 
    	editor.addSidebar('mysidebar', {
		  tooltip: 'My sidebar',
		  icon: 'bullist',
		  
		  onrender: function (api) {
			  console.log('Render panel', api.element());
			  $(api.element()).html(  $('<div id="pm-sidebar-list"></div>') );
			  pm_genSidebar();

		  },
		  onshow: function (api) {
			  console.log('Show panel', api.element());

		  },
		  onhide: function (api) {
			  console.log('Hide panel', api.element());
		  }
   		});
 
 



 editor.on('DblClick', function(e) {
 var mynode = $(e.target);
 var mypnode = mynode.parent();
 
 if ( mypnode.prop('tagName') == 'HEADER' ) {
 
             editor.windowManager.open({
                title: 'Edit ' + mynode.data('name') + ' Name',
			 minWidth: 500,
                id: 'pm-header-dialog',
                body: [
                    { type: 'textbox', name: 'name', id: 'pm-header-value', value: mynode.text() },
			],
			onSubmit:function (e) {
			 mynode.text( $('#pm-header-value').val() );
			
			
			}
			});
 
 
 }

 
 });
 
 
 editor.on('change:options',function() {
 console.log('tttttt');
 
 });

 editor.on('init', function(e) {
    editor.dom.loadCSS(url + '/css/default.css');
    $(tinymce.activeEditor.getBody()).addClass('mceNonEditable'); 
    $(tinymce.activeEditor.getBody()).attr('contenteditable',false);
    
    var mynode = $(tinymce.activeEditor.getBody())[0].childNodes[0];
    
    
    if ( mynode.nodeName != 'ARTICLE' ) {
		mynode.parentNode.removeChild( mynode );
    }
    
    
$(document).on('change','.mce-pm-header-selectbox',function() {

 var mynode = this;
 var tlast=tinymce.activeEditor.getBody();
 var tupdate;
 $('.mce-pm-header-valuelist').each(function(i,obj) {
  var tsplit = $(obj).val().split('\t\|\t');
 
  tlast=$(tlast).children().eq( tsplit[0] );
 
 console.log( 'TAG='+$(this).prop('tagName')+'='+i );
 
  if (  $(obj).is( mynode )  ) {
  console.log('MATCH!');
  //console.log( $(tlast).children()  );
  tupdate =  $(tlast).children('article').map( function(i2,obj2) { console.log('CHIL='+i2+'='+ 'header-'+pm_sectionOrder[(i+1)]+'='+$(obj2).data( 'header-'+pm_sectionOrder[(i+1)])   ); console.log(obj2);  var tval=(''+i2).padStart(10,'0')+"\t|\t"+ $(obj2).data( 'header-'+pm_sectionOrder[(i+1)] );  return $('<option />',{  text:tval, value:tval  })   } )  ;
  
  //console.log(tupdate);
  
  } else if ( $(this).prop('tagName') == 'SELECT' && tupdate != undefined ) {
 
 console.log('EMPTY!');
 console.log( tupdate );
   $(obj).empty();
   
   $(tupdate).each(function(i2,obj2) {
   $(obj).append( obj2 );
   });
   
    tupdate=$();
  
  } 
 
 });


 

 
 
console.log( 'ERR='+$(this).val()  );
 
 
 });
 

    
    
   // tinyMCE.activeEditor.setContent('<article class="mceEditable"><section><p></p></section></article>');
 });


 editor.addCommand('mcePMAddPage', function (ui,args) {
 
 console.log ( 'NODE='+tinymce.activeEditor.selection.getNode().nodeName );
 
 var mymap = pm_map_to_root( tinymce.activeEditor.selection.getNode() );
 
 var mybody = tinymce.activeEditor.getBody();
 
 
 
 tbody=[];
  console.log(  'ppp' );
  
  $.each( pm_sectionOrder, function (i,val) {
  
  if ( pm_sectionOrderHash[val] >= pm_sectionOrderHash[args['type']] ) {
  console.log(  val + '=' + args['type'] );
	
		 tbody.push(
                    { type: 'textbox', label: pm_sectionDef[val]['data-name'] , name: 'name', classes:'pm-header-valuelist', value: '' },
		 );
	
	
	} else {
	
	var toptions=[];
	
	console.log( 'ZZZZZ' );
	$.each(mymap[i],function (i2,obj) {
	
		//if ( $(obj).data('section-depth') <= i   ) {
	//console.log( $(obj).data('header-'+(val)+'') );
		toptions.push( (''+i2).padStart(10,'0')+"\t|\t"+$(obj).data('header-'+(val)+'') );
		//}
     });
			 
			 
			 
 tbody.push(
                    { type: 'selectbox', name: 'name', classes:'pm-header-valuelist pm-header-selectbox', options:toptions },
		 );
		 

		 
		 
		 
	
	}
  


 });
 
 

 console.log('here');
              editor.windowManager.open({
                title: 'Add Name',
			 minWidth: 500,
                id: 'pm-page-dialog',
                body: tbody,
			 onSelect: function () { console.log('ji') },
			onSubmit:function (e) {
			console.log( $($('.mce-pm-header-valuelist')[0]).val() );
			 pm_addPage( $('.mce-pm-header-valuelist').map( function (i,mynode) { console.log(mynode);  return $(mynode).val()  } ) ,  args  );
			
			// mynode.text( $('#pm-header-value').val() );
			
			
			}
			});
			 console.log('here2');
 
 });

 editor.addCommand('mcePMAddHeader', function (ui,args) {
 console.log(args);
	var theader=$('<header />',{ 'contenteditable':false, 'class':'mceNonEditable' });
	
	$.each( args, function (i,val) {
	
		$(theader).append( $('<h'+(i+1)+' />',val) );
	
	});

	
   // $(tinymce.activeEditor.getBody()).find('article').prepend( theader ) ;
 });
 
 
 
  function pm_genSidebar() {
	var tbody=tinymce.activeEditor.getBody();
  console.log('sidebar');
  
$('#pm-sidebar-list').empty();
     $(tbody).find('article').each(function (i2,obj) {


	$('#pm-sidebar-list').append( 
	$('<div/>',{
	html: $(obj).data('header-'+$(obj).data('page-type')),
	style: 'margin: 10px 10px 10px '+( 5 * (parseInt($(obj).data('page-depth'))+1)  )+'px',
	'class': pm_sectionDef[ $(obj).data('page-type') ]['class']
	
	})
	
	);

	
	});

  
  
  }
 
 
 
 function pm_addPage(values,args) {
 
console.log( values );
	var pos = args['pos'];
	var tarchive=[];
	var treg = /^[0-9]+\t\|\t/;
	
 
	//var tpage=$('<article />',{ 'contenteditable':true, 'class':'mceEditable', data });
		var tlast=tinymce.activeEditor.getBody();
		var tfirst;
	$.each( pm_sectionOrder, function (i,val) {
	
	
	if ( treg.test( values[ i ] )  ) {
		tsplit = values[ i ].split('\t\|\t');
	console.log( "SPLIT="+tsplit[0] );
		tarchive[i] =  $(tlast).children().eq( tsplit[0] );
		tlast = tarchive[i];
	} else {
	
		tarchive[i] = $('<article />',{ 'contenteditable':true, 'class':'mceEditable', 'data-page-depth': i, 'data-page-type':pm_sectionOrder[i], ['data-header-'+val] : values[ i ].replace(treg)  });
	
		if ( tfirst == undefined ) {
		tfirst = tarchive[i];
		}
		
		if ( i != 0 ) {
		$(tarchive[(i-1)]).append(tarchive[i]);

		}
		
	}
	});
	
	console.log( tarchive );
	
	tpage=tarchive[ (tarchive.length-1) ];
	
	
	
	
	
	var theader=$('<header />',{ 'contenteditable':false, 'class':'mceNonEditable' });
	
	var newParent=0;
	var header
	$.each( pm_sectionOrder, function (i,val) {
	
		if ( args['type'] == val ) {
		
			newParent=1;
		} else if ( newParent == 1 ) {
		
		
		} else {
		
		}
		

	
	values[ i ]=values[ i ].replace(treg, '');
	
	//console.log( 'CREATE=' + 'header-'+val );

		$(theader).attr( 'data-header-'+val, values[ i ] );
		if ( args['type'] == val ) {
		$(theader).attr( 'data-section-depth', pm_sectionOrderHash[val] );
		}
	
		$(theader).append( $('<h'+(i+1)+' />',  Object.assign( pm_sectionDef[val], { text:values[ i ] } )  ) );
	
	});
	
	var tsection=$('<section />',{ 'contenteditable':true, 'class':'mceEditable' });
	
	tsection.append( $('<p />', { html:'&nbsp;' }) );
	
	tpage.append( theader );
	tpage.append( tsection );
	
	
	
	console.log( 'APPENDTO='+$(tlast)[0].outerHTML );
	
	 $(tlast).append( tfirst ) ;

 pm_genSidebar();
 }
 
 
 
 
  function pm_map_to_root (mynode) {
  
	var ttree=[];
	    var pfind = 0;
	    
	    if ( mynode.nodeName == 'HTML' ) {
	      mynode = $(mynode).find('BODY').get(0);
		 
	    }
	    
	    
    while ( pfind != 1 ) {
	if ( mynode.nodeName == 'BODY' ) {
		pfind=1;
	} 
	
	if ( (mynode.nodeName == 'ARTICLE' || mynode.nodeName == 'BODY') && mynode.childNodes[0].nodeName == 'ARTICLE' ) {
	ttree.push( $.grep( mynode.childNodes, function (cnode) {  if ( cnode.nodeName == 'ARTICLE' ) {  return true; } else { return false; }    }) );
	console.log(ttree);
	}
	
	mynode = mynode.parentNode;
		
    }
    
    
    return ttree.reverse();
  
  }
 
 

});
